// Generated by :tools:generateApis. Do not edit manually.
package dev.jellystack.network.generated.jellyfin

import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.request.headers
import io.ktor.client.request.request
import io.ktor.client.request.setBody
import io.ktor.client.statement.HttpResponse
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpMethod
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.http.path
import io.ktor.http.takeFrom
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

/** Credentials payload for the Jellyfin authenticate-by-name endpoint. */
@Serializable
data class AuthenticateByNameRequest(
    @SerialName("Username")
    val username: String,
    @SerialName("Pw")
    val password: String, // Plain text password for authentication.
    @SerialName("Password")
    val legacyPasswordHash: String? = null, // Optional SHA1 password hash supported by legacy Jellyfin builds.
    @SerialName("DeviceId")
    val deviceId: String? = null,
)

/** Minimal user payload nested within login response. */
@Serializable
data class AuthenticateByNameUser(
    @SerialName("Id")
    val id: String,
    @SerialName("Name")
    val name: String? = null,
)

/** Subset of Jellyfin auth response needed for onboarding. */
@Serializable
data class AuthenticateByNameResponse(
    @SerialName("AccessToken")
    val accessToken: String,
    @SerialName("User")
    val user: AuthenticateByNameUser,
    @SerialName("ServerId")
    val serverId: String? = null,
)

/** Authentication client covering Jellyfin credential login flow. */
class JellyfinAuthApi(
    private val client: HttpClient,
    private val baseUrl: String,
) {
    private fun io.ktor.client.request.HttpRequestBuilder.configureUrl(pathSuffix: String) {
        url {
            takeFrom(baseUrl)
            path(pathSuffix.trimStart('/'))
        }
    }

    /** Authenticate a user by username/password and return access token. */
    suspend fun authenticateByName(payload: AuthenticateByNameRequest): AuthenticateByNameResponse =
        client
            .request {
                method = HttpMethod.Post
                configureUrl("/Users/AuthenticateByName")
                contentType(ContentType.Application.Json)
                headers {
                    append(
                        "X-Emby-Authorization",
                        buildString {
                            append("MediaBrowser Client=\"Jellystack\"")
                            append(", Device=\"")
                            append(payload.deviceId ?: payload.username)
                            append("\"")
                            append(", DeviceId=\"")
                            append(payload.deviceId ?: payload.username)
                            append("\"")
                            append(", Version=\"0.1\"")
                        },
                    )
                }
                setBody(payload)
            }.consumeAsJson()

    private suspend fun HttpResponse.consumeAsJson(): AuthenticateByNameResponse {
        if (!status.isSuccess()) {
            val bodyText = runCatching { bodyAsText() }.getOrNull()
            throw JellyfinAuthHttpException(status.value, bodyText)
        }
        return body()
    }
}

class JellyfinAuthHttpException(
    val code: Int,
    val payload: String?,
) : RuntimeException(
        buildString {
            append("Jellyfin auth failed with status ")
            append(code)
            payload?.takeIf { it.isNotBlank() }?.let {
                append(": ")
                append(it)
            }
        },
    )
